import pool from './database'
import bcrypt from 'bcryptjs'

export interface User {
  id: string  // UUID
  email: string
  phone?: string
  first_name: string
  last_name: string
  password_hash: string
  is_verified: boolean
  is_active: boolean
  two_factor_enabled: boolean
  created_at: Date
  updated_at: Date
  last_login?: Date
}

export interface CreateUserData {
  email: string
  phone?: string
  first_name: string
  last_name: string
  password: string
}

export interface VerificationCode {
  id: string
  user_id: string
  channel: 'email' | 'sms'
  purpose: 'signup' | 'login' | 'password_reset'
  code_hash: string
  expires_at: Date
  used: boolean
  attempts: number
  last_attempt_at?: Date
  created_at: Date
}

export class UserService {
  // Create a new user
  static async createUser(userData: CreateUserData): Promise<User> {
    const client = await pool.connect()
    
    try {
      await client.query('BEGIN')
      
      // Hash password
      const passwordHash = await bcrypt.hash(userData.password, 12)
      
      // Insert user with UUID (generated by database)
      const userResult = await client.query(
        `INSERT INTO users (
          email, phone, first_name, last_name, password_hash, 
          is_verified, is_active
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *`,
        [
          userData.email,
          userData.phone,
          userData.first_name,
          userData.last_name,
          passwordHash,
          false, // is_verified
          false  // is_active (will be true after email verification)
        ]
      )
      
      await client.query('COMMIT')
      return userResult.rows[0]
      
    } catch (error) {
      await client.query('ROLLBACK')
      throw error
    } finally {
      client.release()
    }
  }
  
  // Get user by email
  static async getUserByEmail(email: string): Promise<User | null> {
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email])
    return result.rows[0] || null
  }
  
  // Get user by ID
  static async getUserById(id: string): Promise<User | null> {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [id])
    return result.rows[0] || null
  }
  
    // Verify email with OTP code
  static async verifyEmailWithOTP(userId: string, code: string): Promise<boolean> {
    const client = await pool.connect()
    
    try {
      await client.query('BEGIN')
      
      // Get all active email verification codes for this user
      const codeResult = await pool.query(
        `SELECT id, code_hash, attempts FROM verification_codes 
         WHERE user_id = $1 AND channel = 'email' AND purpose = 'signup'
         AND expires_at > NOW() AND used = false`,
        [userId]
      )
      
      if (codeResult.rows.length === 0) {
        await client.query('ROLLBACK')
        return false
      }
      
      // Check if any of the codes match
      let matchingCodeId = null
      for (const row of codeResult.rows) {
        const isMatch = await bcrypt.compare(code, row.code_hash)
        if (isMatch) {
          matchingCodeId = row.id
          break
        }
      }
      
      if (!matchingCodeId) {
        // Increment attempts for all codes
        await client.query(
          `UPDATE verification_codes 
           SET attempts = attempts + 1, last_attempt_at = NOW() 
           WHERE user_id = $1 AND channel = 'email' AND purpose = 'signup' AND used = false`,
          [userId]
        )
        await client.query('ROLLBACK')
        return false
      }
      
      // Mark code as used
      await client.query(
        `UPDATE verification_codes 
         SET used = true, last_attempt_at = NOW() 
         WHERE id = $1`,
        [matchingCodeId]
      )
      
      // Update user as verified and active
      await client.query(
        `UPDATE users 
         SET is_verified = true, 
             is_active = true,
             updated_at = NOW()
         WHERE id = $1`,
        [userId]
      )
      
      await client.query('COMMIT')
      return true
      
    } catch (error) {
      await client.query('ROLLBACK')
      throw error
    } finally {
      client.release()
    }
  }
  
  // Generate new OTP verification code
  static async generateOTPCode(userId: string, type: 'email' | 'phone'): Promise<string> {
    const client = await pool.connect()
    
    try {
      const otpCode = Math.floor(100000 + Math.random() * 900000).toString() // 6-digit OTP
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000) // 10 minutes
      
      // Hash the OTP code before storing
      const codeHash = await bcrypt.hash(otpCode, 10)
      
      // Delete any existing unused codes for this user and type
      await client.query(
        `DELETE FROM verification_codes 
         WHERE user_id = $1 AND channel = $2 AND purpose = 'signup' AND used = false`,
        [userId, type]
      )
      
      // Insert new verification code
      await client.query(
        `INSERT INTO verification_codes (user_id, channel, purpose, code_hash, expires_at, used, attempts)
         VALUES ($1, $2, $3, $4, $5, false, 0)`,
        [userId, type, 'signup', codeHash, expiresAt]
      )
      
      return otpCode // Return the plain code to send via email/SMS
      
    } catch (error) {
      throw error
    } finally {
      client.release()
    }
  }
  
  // Authenticate user
  static async authenticateUser(email: string, password: string): Promise<User | null> {
    const user = await this.getUserByEmail(email)
    
    if (!user || !user.is_active) {
      return null
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password_hash)
    
    if (!isPasswordValid) {
      return null
    }
    
    // Update last login
    await pool.query(
      `UPDATE users SET last_login = NOW(), updated_at = NOW() WHERE id = $1`,
      [user.id]
    )
    
    return user
  }
}
